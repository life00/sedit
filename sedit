#!/bin/sh

# setting environment variables
user="user"
EDITOR="${EDITOR:-/bin/vi}"
vcode="" # validity passcode to verify the session

# error checking
if [ -n "${2}" ]; then
	printf "[!] :%s: Expected only one argument\n" "${vcode}"
	exit 1
elif [ -z "${1}" ]; then
	printf "[!] :%s: No file path provided\n" "${vcode}"
	exit 1
elif [ "$(id -u)" -ne 0 ]; then
	printf "[!] :%s: Should be run as root\n" "${vcode}"
	exit 1
fi

# exit if any code errors
# error when using unset variables
set -eu

# temporary directory
tmpdir="$(mktemp -d)"

# remove temporary directory when script exits
trap "rm -rf '${tmpdir}'" EXIT

# copy file and set appropriate permissions
chmod 755 "${tmpdir}"
touch "${tmpdir}"/edit
chmod 600 "${tmpdir}"/edit
chown "${user}":"${user}" "${tmpdir}"/edit
cat "${1}" >"${tmpdir}"/edit

# open file in ${EDITOR} as ${user}

# use machinectl if you are on a systemd system (recommended); arguably it is the most secure method
machinectl shell "${user}"@.host "${EDITOR}" "${tmpdir}"/edit

# use GNU su when you are using GNU coreutils; arguably it is less secure method
# su "${user}" -P -s /bin/sh -c '"${1}" "${2}"' sedit "${EDITOR}" "${tmpdir}"/edit

# use sudo if you have it installed; its about the same security as using su
# IMPORTANT: make sure you have 1.9.14< version installed so that use_pty is used by default
# otherwise using sudo to spawn unprivileged session is NOT SAFE and is vulnerable to privilege escalation exploit
# the default state of this option might change in the future versions so its better to set it explicitly in the config anyways
# sudo -u "${user}" /bin/sh -c '"${1}" "${2}"' sedit "${EDITOR}" "${tmpdir}"/edit

# reverse permission changes
# creating a separate file to prevent a potential attack using uncommon ACLs
chmod 700 "${tmpdir}"
touch "${tmpdir}"/final
chmod 600 "${tmpdir}"/final
chown "root:root" "${tmpdir}"/edit
chmod 600 "${tmpdir}"/edit
cat "${tmpdir}"/edit >"${tmpdir}"/final

# checking for changes
# the original file is not copied to temporary directory because I believe it is unnecessary
# it is not expected that something overwrites the original file during editing
# if something does then it will be visible in the diff
if cmp -s "${tmpdir}"/edit "${1}"; then
	printf "[+] :%s: Skipping write; no changes.\n" "${vcode}"
	exit 0
else
	# provide a diff of changes
	printf "[+] :%s: Changes made:\n" "${vcode}"
	# suppress error code response of diff
	diff --color "${1}" "${tmpdir}"/final || true
	# confirming changes
	printf "[?] :%s: Continue? [y/N]: " "${vcode}"
	read -r resp
	printf "\n"
	if [ "${resp}" = "y" ] || [ "${resp}" = "Y" ]; then
		# overwrite the original file
		cat "${tmpdir}"/final >"${1}"
		exit 0
	else
		exit 1
	fi
fi
